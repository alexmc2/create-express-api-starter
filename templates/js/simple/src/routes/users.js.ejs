<% if (educational) { %>// File overview: Defines /api/users routes, including request validation and repository calls.
<% } %>
<% if (isEsm) { %>import { Router } from 'express';

import AppError from '../errors/AppError.js';
import usersRepository from '../repositories/usersRepository.js';
<% } else { %>const express = require('express');

const usersRepository = require('../repositories/usersRepository');
const AppError = require('../errors/AppError');
<% } %>

<% if (isEsm) { %>const router = Router();
<% } else { %>const router = express.Router();
<% } %>

<% if (educational) { %>// Async route handlers should pass failures to next(error) so the
// centralized error handler can return a consistent HTTP response.
<% } %>router.get('/', async (_req, res, next) => {
  try {
    const users = await usersRepository.getAll();
    res.status(200).json(users);
  } catch (error) {
    next(error);
  }
});

router.post('/', async (req, res, next) => {
  try {
<% if (educational) { %>    // Validate input at the API boundary before storing data.
    // Calling next(error) skips the rest of the handler and moves control
    // to the central error middleware, which formats the HTTP response.
<% } %>    const { name, email } = req.body ?? {};

    if (!name || typeof name !== 'string') {
      return next(new AppError(400, '"name" is required.'));
    }

    const user = await usersRepository.create({
      name: name.trim(),
      email: typeof email === 'string' ? email.trim() : null
    });

    return res.status(201).json(user);
  } catch (error) {
    return next(error);
  }
});

<% if (isEsm) { %>export default router;
<% } else { %>module.exports = router;
<% } %>
