<% if (educational) { %>// File overview: Encapsulates user data access so controllers/services stay focused on API behavior.
<% } %>
<% if (isPostgres) { %><% if (educational) { %>// Keep SQL statements in the repository so HTTP layers stay focused on requests
// and responses. This separation makes the code easier to test and maintain.
<% } %>import pool from '../db/pool';

interface UserRow {
  id: number;
  name: string;
  email: string | null;
}

interface CreateUserInput {
  name: string;
  email: string | null;
}

async function getAll(): Promise<UserRow[]> {
  const result = await pool.query<UserRow>('SELECT id, name, email FROM users ORDER BY id ASC');
  return result.rows;
}

async function create({ name, email }: CreateUserInput): Promise<UserRow> {
<% if (educational) { %>  // Use parameter placeholders ($1, $2) so pg binds values safely.
<% } %>  const result = await pool.query<UserRow>(
    'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, name, email',
    [name, email]
  );

  return result.rows[0];
}

export default {
  getAll,
  create
};
<% } else { %><% if (educational) { %>// Keep data access in one place so the rest of the app does not depend on
// storage details. This in-memory version can be replaced later with a real
// database by changing this file only.
<% } %>export interface User {
  id: number;
  name: string;
  email: string | null;
}

interface CreateUserInput {
  name: string;
  email: string | null;
}

const users: User[] = [
  {
    id: 1,
    name: 'Ada Lovelace',
    email: 'ada@example.com'
  },
  {
    id: 2,
    name: 'Grace Hopper',
    email: 'grace@example.com'
  }
];

let nextId = users.length + 1;

async function getAll(): Promise<User[]> {
  return users;
}

async function create({ name, email }: CreateUserInput): Promise<User> {
  const user: User = {
    id: nextId,
    name,
    email
  };

  nextId += 1;
  users.push(user);

  return user;
}

export default {
  getAll,
  create
};
<% } %>
